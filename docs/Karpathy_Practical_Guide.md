# Karpathy 실전 개발 가이드 (수익화 중심)

> **대상**: 여러 제품 운영하는 솔로 개발자 + 교육자  
> **목표**: 빠른 수익화 + 견고한 코드베이스  
> **핵심**: "대충 만들면 결국 더 오래 걸린다"

**Version**: 1.0  
**Last Updated**: 2026-01-14

---

## 📚 목차

1. [기본 철학](#1-기본-철학)
2. [2시간 룰 (핵심!)](#2-2시간-룰-핵심)
3. [개발 모드 선택](#3-개발-모드-선택)
4. [실전 시나리오](#4-실전-시나리오)
5. [VSCode ↔ Claude Code 워크플로우](#5-vscode--claude-code-워크플로우)
6. [체크리스트 모음](#6-체크리스트-모음)

---

## 1. 기본 철학

### "대충 vs 제대로"의 함정

```
❌ 잘못된 생각:
"빨리 만들려면 대충 만들어야지"

✅ 현실:
대충 만들기 → 디버깅 2-3일 → 중간에 보류 → 다시 시작
처음부터 제대로 → 하루 완성 → 바로 판매

결론: 천천히가 빠르다
```

### Karpathy의 핵심 통찰

> **"바이브 코딩은 버리기 좋은 주말 프로젝트에는 나쁘지 않다."**

하지만 당신은:
- 주말 프로젝트가 아님 (수익화 목표)
- 버릴 게 아님 (고객에게 판매)
- 유지보수 해야 함 (당신이 책임짐)

∴ **선택적 바이브 코딩** 필요

### 시간 역설

| 접근 방식 | 초기 | 디버깅 | 수정 | 총합 |
|----------|------|--------|------|------|
| 대충 만들기 | 4시간 | 2-3일 | 1-2일 | **4-6일** |
| 처음부터 제대로 | 8시간 | 2-4시간 | - | **1일** |

---

## 2. 2시간 룰 (핵심!)

> **"2시간 = 위험 신호"**

### 2시간 체크포인트

같은 문제에 2시간 이상 막혔다면:

```
┌─ 2시간 경과 ────────────────────────────┐
│                                        │
│  🚨 멈춰! 뭔가 잘못됐다                  │
│                                        │
│  접근 방법을 바꿔야 할 시점              │
│                                        │
└────────────────────────────────────────┘
```

### 체계적 대응 프로토콜

#### Step 1: 문제 유형 분류 (5분)

```
내가 막힌 이유는?
├─ A) 디버깅 늪
│   "에러는 나는데 원인을 모르겠음"
│
├─ B) 기능 구현 실패
│   "아예 어떻게 만들지 모르겠음"
│
└─ C) 아키텍처 연결
    "부분은 만들었는데 어떻게 연결할지 모르겠음"
```

#### Step 2: 유형별 대응 (30분 제한)

**A) 디버깅 늪:**
```bash
1. /error-log 실행
2. Claude에게 요청:
   "이 에러 메시지 분석해줘. 가능한 원인 3가지만"
   
3. 각 원인 체크 (10분씩)
   □ 원인 1 체크 → 해결?
   □ 원인 2 체크 → 해결?
   □ 원인 3 체크 → 해결?
   
4. 30분 안에 해결 안 되면 → AI 활용 전환
```

**B) 기능 구현 실패:**
```bash
1. 공식 문서 Quick Start (15분)
   → 최소 예제 실행 가능?
   
2. YES → 예제 → 우리 프로젝트 적용 (손코딩)
   NO  → AI 구현 받기 (단, 설명 필수)
   
3. AI 받을 때:
   "이 기능을 구현해줘. 
    단, 구현 후 코드 주요 부분 설명해줘"
```

**C) 아키텍처 연결:**
```bash
1. Boris Plan Mode
   Claude에게: "이 부분들을 어떻게 연결할지 계획 세워줘"
   
2. 계획 검토 → 이해됨?
   YES → 손코딩으로 연결
   NO  → AI에게 연결 맡기고 코드 리뷰
```

### 1일 룰

```
같은 문제에 1일 이상 막혔다면:
→ 프로젝트 보류 ❌
→ 모드 전환 ✅

손코딩 모드 → Speed Mode 전환
"일단 AI로 만들고 나중에 이해하자"
```

---

## 3. 개발 모드 선택

### 프로젝트 시작 시 결정

```
이 프로젝트는?
├─ MVP 검증 단계?
│   → Speed Mode (AI 활용 극대화)
│
└─ 판매/확장 단계?
    → Quality Mode (처음부터 제대로)
```

### Speed Mode (MVP 검증)

**언제 사용:**
- 아직 고객 검증 안 됨
- 빠른 프로토타입 필요
- 버릴 수도 있는 기능

**규칙:**
```markdown
✅ 허용:
- AI가 대부분 구현
- 빠른 더티 코드
- 테스트 최소화

⚠️ 단, 필수:
- /check-complete (미연결 방지)
- 스펙 준수 체크 (PRD 확인)
- Gate PASS (기본 품질)
```

**예시 (PathcraftAI):**
```
YouTube API 통합 테스트
→ Speed Mode
→ AI에게 전체 구현 요청
→ 동작 확인 후 고객 피드백
→ 피드백 좋으면 Quality Mode로 재작성
```

### Quality Mode (판매/확장)

**언제 사용:**
- 고객 검증 완료
- 실제 판매 중
- 장기 운영 예정

**규칙:**
```markdown
✅ 필수:
- 핵심 로직 손코딩
- 이해 못하면 Accept 금지
- 전체 테스트 커버리지

🤝 협업:
- 반복 작업 → AI
- 보일러플레이트 → AI
- 스타일링 → AI
```

**예시 (AdGen 카드뉴스 생성기):**
```
이미 고객이 쓰고 있음
→ Quality Mode
→ 템플릿 생성 로직: 손코딩
→ UI 컴포넌트: AI 활용
→ 이미지 처리: 공식 라이브러리 + 손코딩 연결
```

---

## 4. 실전 시나리오

### 시나리오 A: 기능 구현 후 미연결

**문제:**
```
AI가 기능은 만들었는데...
- import 안 됨
- 라우팅 없음
- UI에서 호출 안 됨
```

**예방 (사전):**
```bash
/plan 단계에서 명확히:
"YouTube API 연동 기능을 만들어줘.
 
필수 요구사항:
1. src/lib/youtube.ts 생성
2. app/api/youtube/route.ts 생성
3. 컴포넌트에서 사용하는 hook 생성
4. 실제 UI에서 호출되게 연결
5. /check-complete로 확인"
```

**감지 (중간):**

/check-complete 체크리스트:
```markdown
□ 생성한 파일이 다른 곳에서 import 되나?
□ API 라우트가 등록됐나?
□ UI에 버튼/링크 있나?
□ 버튼 클릭하면 실제로 API 호출되나?
□ Network 탭에서 요청 보이나?
```

**수정 (사후):**
```bash
Claude에게:
"/check-complete 체크리스트를 확인했어.
 4번이 안 됨. UI 컴포넌트 연결 부분만 추가해줘."
```

### 시나리오 B: AI가 스펙 무시하고 자기 맘대로

**문제:**
```
PRD: "YouTube 검색 결과 10개만"
AI: 20개 가져오고 페이지네이션까지 만듦
```

**예방 (사전):**
```markdown
/plan 단계에서:
"PRD 확인: docs/PRD.md의 F-003 스펙 준수

YouTube 검색 API 연동:
- 정확히 10개 결과만 반환
- 페이지네이션 없음 (PRD에 없음)
- 추가 기능 절대 금지"
```

**감지 (중간):**

구현 후 즉시 확인:
```bash
git diff

# PRD와 다른 부분 찾기
# "이거 PRD에 없는데?" → 즉시 제거 요청
```

**수정 (사후):**
```bash
Claude에게:
"페이지네이션 부분은 PRD에 없어.
 제거하고 정확히 10개만 반환하도록 수정해줘.
 
 PRD F-003:
 [복붙]"
```

### 시나리오 C: 디버깅 늪 (실전 예시)

**상황:**
```javascript
// YouTube API 호출
const response = await fetch('/api/youtube');
const data = await response.json();
// ❌ TypeError: Cannot read property 'items'
console.log(data.items);
```

**2시간 룰 적용:**

```bash
# 체크포인트 1: 에러 메시지 (10분)
→ response 구조 확인
→ console.log(data) 찍어보기

# 체크포인트 2: API 응답 확인 (20분)
→ Network 탭 확인
→ Postman으로 직접 호출
→ 실제 응답 구조 파악

# 체크포인트 3: 공식 문서 (30분)
→ YouTube Data API 문서
→ 응답 형식 확인
→ "아, items가 아니라 data.items.items구나!"

# 1시간 경과, 여전히 안 됨
→ /error-log 실행

# 1.5시간 경과
→ Claude에게:
   "YouTube API 응답을 파싱하는데 계속 에러가 나.
    이 에러 로그 보고 원인 찾아줘.
    [에러 로그 전체 복붙]"

# 2시간 경과
→ AI 솔루션 Accept
→ 단, "왜 이렇게 해야 하는지" 설명 듣기
```

---

## 5. VSCode ↔ Claude Code 워크플로우

### 기본 설정

```
환경:
- Claude Code CLI (메인 대화)
- VSCode (코드 작성)
```

### 손코딩 플로우

**Step 1: Claude에게 설명 요청**
```bash
# Claude Code CLI에서
"YouTube API 연동 로직을 만들어야 해.
 구현하지 말고, 어떻게 만들어야 하는지만 설명해줘.
 
 필요한 것:
 1. API 엔드포인트
 2. 요청 파라미터
 3. 응답 파싱 방법"
```

**Step 2: VSCode에서 직접 타이핑**
```typescript
// src/lib/youtube.ts
// Claude 설명 보면서 한 줄씩 이해하며 작성

export async function searchVideos(query: string) {
  // 1. API 엔드포인트 (Claude 설명대로)
  const url = `...`;
  
  // 2. 요청 파라미터 (이해하면서 작성)
  const params = { ... };
  
  // 3. 응답 파싱 (단계별로 확인)
  const response = await fetch(url);
  const data = await response.json();
  
  return data.items; // 여기 items가 맞나? 확인
}
```

**Step 3: 막히면 즉시 질문**
```bash
# Claude에게
"이 부분이 이해가 안 돼:
 [해당 코드 복붙]
 
 특히 이 부분:
 - data.items가 undefined일 때 어떻게 처리?
 - 에러 핸들링은?"
```

**Step 4: 완성 후 검증 요청**
```bash
# Claude Code CLI
"내가 작성한 코드를 리뷰해줘:
 [전체 코드 복붙]
 
 특히 체크해줘:
 1. 에러 핸들링
 2. 타입 안전성
 3. 예외 케이스"
```

### AI 활용 플로우 (반복 작업)

**Step 1: Claude에게 구현 요청**
```bash
"UI 컴포넌트 스타일링 해줘:
 - Tailwind 사용
 - 카드 레이아웃
 - 반응형
 
 기존 컴포넌트:
 [코드 복붙]"
```

**Step 2: 결과 확인 후 Accept**
```bash
# VSCode에서 diff 확인
# 이해 가능한 변경인지 체크
# Accept
```

**Step 3: /check-complete**
```bash
# 실제로 동작하는지 확인
npm run dev
# 브라우저에서 확인
```

---

## 6. 체크리스트 모음

### 프로젝트 시작 시

```markdown
□ 이 프로젝트의 모드는? (Speed / Quality)
□ PRD 작성 완료? (docs/PRD.md)
□ 핵심 로직 파악 (어디를 손코딩?)
□ AI 활용 범위 정의 (어디를 AI에게?)
□ 2시간 룰 알림 설정
```

### 기능 구현 시

```markdown
□ /plan 실행 (계획 수립)
□ 스펙 명확히 (PRD 참조)
□ 손코딩 vs AI 판단
□ 막히면 2시간 룰 적용
□ /check-complete (미연결 체크)
```

### 완료 전

```markdown
□ /check-complete PASS
□ /gate PASS
□ /handoff 기록
□ /verify (새 세션)
□ 실제 동작 확인 (E2E)
```

### 디버깅 시 (2시간 룰)

```markdown
[30분 체크포인트]
□ 에러 메시지 읽음
□ console.log 찍음
□ Network 탭 확인

[1시간 체크포인트]
□ 공식 문서 확인
□ Stack Overflow 검색
□ 비슷한 코드 참고

[1.5시간 체크포인트]
□ /error-log 실행
□ Claude에게 분석 요청

[2시간 체크포인트]
🚨 접근 방법 전환!
□ AI 솔루션 활용
□ 설명 듣고 이해
□ 나중에 재학습 TODO
```

### 모드 전환 시

**Speed → Quality:**
```markdown
고객 검증 완료, 이제 판매 시작

□ 핵심 로직 파악
□ 손코딩 재작성 계획
□ 우선순위 정리 (어디부터?)
□ 리팩토링 일정
□ 테스트 추가
```

**Quality → Speed:**
```markdown
1일+ 막힘, 일단 진도 필요

□ 현재 상태 저장 (git commit)
□ AI에게 구현 요청
□ 동작 확인
□ TODO 추가: "나중에 이해하기"
□ 다음 기능 진행
```

---

## 📚 추가 리소스

### Karpathy 명언 (기억할 것)

> **"바이브에 완전히 몸을 맡기고, 코드가 존재한다는 사실 자체를 잊어버리는... 버리기 좋은 주말 프로젝트에는 나쁘지 않다."**

→ 당신은 버릴 게 아니니까 선택적으로!

> **"nanochat은 거의 전적으로 손으로 작성. Claude는 전혀 도움 안 됨."**

→ 진짜 중요한 건 손코딩

> **"영웅이 되려 하지 말라. 가장 단순한 아키텍처를 복붙하라."**

→ 검증된 패턴 사용

### Boris 검증 프로토콜

> **"피드백 루프가 있으면 품질이 2-3배 올라간다"**

→ /clear → /verify 필수

### Shovel 골든 룰

> **"천천히가 빠르다"**

→ 대충 만들면 결국 더 오래 걸림

---

## 🎯 요약 (벽에 붙여놓을 것)

```
1. 핵심 로직 = 손코딩 시도
2. 2시간 막히면 = 방법 전환
3. 대충 만들면 = 나중에 발목
4. AI 받을 땐 = 설명 필수
5. 완료는 = Gate PASS만
```

---

**Version**: 1.0  
**Last Updated**: 2026-01-14  
**For**: 수익화 목표 솔로 개발자
